---
- name: Provision resource group in Azure
  hosts: localhost
  gather_facts: false

  # Temporary
  vars:
    resource_group_name: azure_poc_ptoal
    storage_account_name: ptoalpoc
    operating_system: other
    publisher: MicrosoftWindowsServer
    version: latest
    offer: WindowsServer
    azureuser: azadmin
    azurepassword: !vault |
          $ANSIBLE_VAULT;1.2;AES256;rhdemo
          35336464363933383136343062663761653365663936393366636233616166653830303932316165
          3161386333396139313938646666656336626632343534660a393463326333383330353739623862
          37363165393735636361383861633133643335316135396661376439353066356364626636666638
          6335613735343534340a633764343532656435353265303534353562343061643334313539663939
          65366133366239363330623261643266303764616465323465376433376436636263
    sku: 2022-datacenter-azure-edition-core
    vm_size: Standard_B1s
    # vm_names: "{{ vm_name.split(',') }}"
    vm_names:
      - "{{ new_vm_hostname }}"

  tasks:
    - name: Resource Group Creation
      ansible.builtin.include_role:
        name: azure_create_resource_group

    - name: Storage Account Creation
      ansible.builtin.include_role:
        name: azure_create_storage_account

    - name: Provision instance Windows
      azure.azcollection.azure_rm_virtualmachine:
        resource_group: "{{ resource_group_name }}"
        name: "{{ item }}"
        storage_account: "{{ storage_account_name }}"
        admin_username: "{{ azureuser }}"
        admin_password: "{{ azurepassword }}"
        vm_size: "{{ vm_size }}"
        os_type: Windows
        managed_disk_type: Standard_LRS
        open_ports:
          - 22
          - 5985
          - 5986
          - 80
          - 443
        image:
          publisher: "{{ publisher }}"
          offer: "{{ offer }}"
          version: "{{ version }}"
          sku: "{{ sku }}"
      register: azure_vm
      loop: "{{ vm_names }}"
      when: publisher == "MicrosoftWindowsServer"

    - name: Create VM script extension to enable HTTPS WinRM listener
      azure.azcollection.azure_rm_virtualmachineextension:
        name: winrm-extension
        resource_group: "{{ resource_group_name }}"
        virtual_machine_name: "{{ item }}"
        publisher: Microsoft.Compute
        virtual_machine_extension_type: CustomScriptExtension
        type_handler_version: "1.9"
        settings: '{"fileUris": ["https://raw.githubusercontent.com/ansible/ansible-documentation/devel/examples/scripts/ConfigureRemotingForAnsible.ps1"],"commandToExecute": "powershell
          -ExecutionPolicy Unrestricted -File ConfigureRemotingForAnsible.ps1"}'
        auto_upgrade_minor_version: true
      loop: "{{ vm_names }}"
      when: publisher == "MicrosoftWindowsServer"

    - name: Loop to verify WinRM
      ansible.builtin.include_tasks: enable_winrm_loop_azure.yml
      loop: "{{ vm_names }}"
      when: publisher == "MicrosoftWindowsServer"

    - name: Execute Powershell script
      ansible.windows.win_powershell:
        script: |
          function Optimize-Assemblies {
          param (
              [string]$assemblyFilter = "Microsoft.PowerShell.",
              [string]$activity = "Native Image Installation"
          )

          try {
              # Get the path to the ngen executable dynamically
              $ngenPath = [System.IO.Path]::Combine([Runtime.InteropServices.RuntimeEnvironment]::GetRuntimeDirectory(), "ngen.exe")

              # Check if ngen.exe exists
              if (-Not (Test-Path $ngenPath)) {
                  Write-Host "Ngen.exe not found at $ngenPath. Make sure .NET Framework is installed."
                  return
              }

              # Get a list of loaded assemblies
              $assemblies = [AppDomain]::CurrentDomain.GetAssemblies()

              # Filter assemblies based on the provided filter
              $filteredAssemblies = $assemblies | Where-Object { $_.FullName -ilike "$assemblyFilter*" }

              if ($filteredAssemblies.Count -eq 0) {
                  Write-Host "No matching assemblies found for optimization."
                  return
              }

              foreach ($assembly in $filteredAssemblies) {
                  # Get the name of the assembly
                  $name = [System.IO.Path]::GetFileName($assembly.Location)

                  # Display progress
                  Write-Progress -Activity $activity -Status "Optimizing $name"

                  # Use Ngen to install the assembly
                  Start-Process -FilePath $ngenPath -ArgumentList "install `"$($assembly.Location)`"" -Wait -WindowStyle Hidden
              }

              Write-Host "Optimization complete."
          } catch {
              Write-Host "An error occurred: $_"
          }
          }

          # Optimize PowerShell assemblies:
          Optimize-Assemblies -assemblyFilter "Microsoft.PowerShell."